---
title: "Mixed models: handling clusters"
author: "(Marcello Gallucci)"
nickname: mixed_clusters
topic: mixed
category: example
output: 
  html_document:
     includes:
         in_header: ganalytics.txt
     toc: true
     toc_float:
        collapsed: false
---

```{r echo=FALSE,results='hide'}
library(mcdocs)
mcdocs_init()
```


`r keywords("power analysis, mixed models, multiple clusters, participant by stimuli")`


`r version("0.8.2")`

Here we discuss some rule to handle clustering variables (grouping variables) in different designs.

# One clustering variable

Simple design with one clustering variable are defined by simply specify in `r opt("Model Syntax")` the "bars" component of the formula, such as:

```
y~1*1+1*x+(1*1|cluster)
```

:::{ .adm .adm-note}
Note

Hereinafter the coefficients are immaterial for our discussion, so we set them always to 1 and assume random intercepts only. The sample structure is not alter by the coefficients values or the definition of fixed and random effects. We also fill in all the clusters numerosities: `# Cluster Levels` and `N per cluster`. It is clear, that depending on the aim of the analysis, one of this parameter is found by the algorightm.

:::


`r modulename()` reads `cluster` as the name of the clustering variable and shows the fields to be filled in to generate the correct sample based on the cluster variable definition. 

`r pic("examples/mixed/example1/e1.input.1.png")`

Now, depending on the aim of the analysis one needs to fill one of the fields (`# Cluster Levels` or `N per cluster`). Here we discuss the meaning of these fields, knowing that depending on the aim of the analysis one of them would be the target of the power function.

With one clustering variable, `# Cluster levels` is the number of groups clustering the observations. In a multilevel design, say, with pupils clustered within classes, `# Cluster levels` is the number of classes in the sample (or to be established by the power analysis). In a repeated measures design, with some condition repeated within participants, `# Cluster levels` is the number of participants.


`N per cluster` is the number of observations within each cluster level (group). In a multilevel design, say, with pupils clustered within classes, `N per cluster` is the (average) number of pupils in the sample (or to be established by the power analysis). In a repeated measures design, with some condition repeated within participants, `N per cluster` is the number of measurement taken for each participants.

With one clustering variable, `N per cluster` should be at least 2, because without at least two measures for each cluster not even a random intercept can be estimated. In order to estimate random slopes, `N per cluster` larger than 2 is requires, otherwise the model would not have enough degrees of freedom to estimate the coefficients variance.

### One-way repeated measure AVOVA design

Assume we have a RM design with four times (see an example in `r link_pages(nickname="ros_mixed_rm")`) and one measure for participants (identified by the variable _ID_) for each time. To define this design, we would input

```
y~1*1+1*time+(1*1|ID)
```

then we specify that `time` is a categorical variable with 4 levels.

`r pic("examples/mixed/example1/e1.input.2.png")`

and we specify the cluster `N per cluster` to 4, indicating that one participant (the cluster group) has 4 observations.

`r pic("examples/mixed/example1/e1.input.3.png")`

The resulting data would look like this:

```
             y time      ID
1   0.64342217    1       1
2   0.15874249    2       1
3  -0.70961322    3       1
4  -1.46269242    4       1
5  -0.80773575    1       2
6   0.38518147    2       2
7  -1.95162686    3       2
8   2.98249154    4       2
9  -0.04821753    1       3
10 -1.61386528    2       3
11 -0.68877198    3       3
12  1.33885528    4       3

```

We can see that time is repeated within ID, with one measurement for each level of time.

:::{ .adm .adm-note}
Note

To see an example of data generated by your model in `r modulename()`, simply select the option `r opt("Data structure")` in `r opt_panel("Options")` 

:::



Assume now we have a similar design, but that within each time condition, the participant is measured 5 times (ten trials). We still have the same model

```
y~1*1+1*time+(1*1|ID)
```

and the same variable definition (time with 4 levels), but now the `N per cluster` is 20, which is 4 levels of time X 5 trials.

`r pic("examples/mixed/example1/e1.input.4.png")`

The resulting data look like this (first participant):

```
              y time      ID
1    0.38563267    1       1
2    1.24833377    1       1
3   -0.76549380    1       1
4   -0.94633446    1       1
5    0.72747486    1       1
6   -0.58658441    2       1
7   -1.01631241    2       1
8   -2.66731584    2       1
9    0.62401507    2       1
10   0.15654240    2       1
11  -0.26135861    3       1
12   0.11923442    3       1
13   0.66327673    3       1
14  -0.63811091    3       1
15   0.31462810    3       1
16   0.27796168    4       1
17   0.32836307    4       1
18  -0.34867872    4       1
19  -0.20470434    4       1
20  -0.71480958    4       1
```

:::{ .adm .adm-note}
Note

Notice that categorical variables are always build to vary within clusters. This is not a problem to model between-participants variables, because in power analysis a categorical variable without random slopes gives the same results whether is within or between subjects. The two types of variables gives different results only when the within-subject variable has random slopes, a feature a between-subject variable never has.

:::

# Multi-cluster designs

Here we tackle the cases with more than one cluster variable. Two cases are salient for researchers: cross-classified clustering and nested clustering. 

### Cross-classified clusters

A typical example of cross-classified clustering is an experimental design in which $P$ participants (identified with variable _PID_) are tested with $S$ stimuli (variable _SID_). So, every participant is exapose to each stimuli, and each stimulus is seen by all participants. We start with the simpler example in which there is only one measurement for each combination of participant and stimulus (a participant sees a stimulus only once).

The mixed model is :

```
y~1*1+1*x+(1*1|PID)+(1*1|SID)
```

Let's say we want a sample of 10 participants and 5 stimuli. In total, we have 50 observations in which each participant has a `N per cluster` equal to 1, and each stimulus has a `N per cluster` equal to 1 as well. It may seems counterintuive, but the participant is actually repeated only once, but their measurament is spread across 5 stimuli. Thus, we need to set

`r pic("examples/mixed/example1/e2.input.1.png")`

The resulting data (first participant) will look like this:

```
        y       PID SID
1   0.741008569   1   1
2  -1.001295926   1   2
3   0.728456584   1   3
4   0.649785351   1   4
5  -1.373459856   1   5
6  -2.073459856   1   6


```

Now, what about a categorical variable (i.e. experimental factor named _cond_). If the variable is _between-subjctes_, we simply declare it as above. For a 4-levels _cond_, we have (first two participants):

```
             y    cond PID SID
1   0.21678164    1   1   1
2  -1.89497678    2   1   2
3   0.68536365    3   1   3
4  -0.50112451    4   1   4
5  -0.03173882    1   1   5
6   0.10935699    2   1   6
7  -0.03479272    3   2   1
8   0.79953612    4   2   2
9   1.16768781    1   2   3
10  0.01980561    2   2   4
11 -0.67931988    3   2   5
12  0.12628890    4   2   6

```

(recall that for between-subjects factors their structure does not affect the results). 

If the variable is _within-subjctes_, we need to be sure that the number of observations per participant (here 6) is a multiple of its levels. With 6 observations, _cond_ can be a 2-levels, 3-levels or 6-levels, otherwise it cannot be repeated within participant. A 2-level factor would look like this:

```
             y cond PID SID
1   0.49915152    1   1   1
2   0.74412274    2   1   2
3  -1.13346819    1   1   3
4   0.86378973    2   1   4
5  -0.13518382    1   1   5
6   1.16554628    2   1   6

```

A more complex design is when the repeated measure factor _cond_ is repeated both within participant and within stimulus. Say that each participant see each stimulus in both conditions of the factor _cond_. This implies that each stimulus has two observations, so we change its `N per cluster`.


`r pic("examples/mixed/example1/e2.input.2.png")`

and we get the design we need:

```
              y cond PID SID
1    1.61187894    1   1   1
2    0.41588941    2   1   1
3   -0.88306925    1   1   2
4   -0.42600560    2   1   2
5   -0.71458546    1   1   3
6   -1.00448085    2   1   3
7   -0.98879046    1   1   4
8    0.91321802    2   1   4
9    0.81331414    1   1   5
10   0.54411584    2   1   5
11  -0.15936292    1   1   6
12  -1.03945842    2   1   6
```

with the same logic, we can simulate a design with several trials within each combinations of participant and stimulus. For instance, with the following setup

`r pic("examples/mixed/example1/e2.input.3.png")`

each participants sees all stimuli 9 times.

### Nested clusters classification

Let us consider one of the most classic multi-level design. Pupils with classes within schools. In this design, we have to clustering variables: _class_ and _school_. To use the multi-level jargon, pupils are level 0, classes are level 1 with pupils nested within classes, and schools are level 2 with classes nested with schools. To be practical, let us assume we want a sample with 10 schools, each with 6 classes, which each class (an everage of) 12 pupils.

First, we set the model

```
y~1*1+1*x+(1*1|school/class)
```

Then we specify that we have 10 schools each with 6 classes, with 12 observations (pupils) each.

`r pic("examples/mixed/example1/e2.input.1.png")`

The generated data looks pretty much like the cross-classified data.

```
row   y             x           school  class
1    0.456717064 -1.017673137      1     1
2   -1.495551991  0.694440645      1     1
3   -0.480543438  0.194002872      1     1
4    0.293003240 -0.116523555      1     1
5   -1.702547420 -1.203825265      1     1
6    1.014035495  0.461345298      1     1
7   -0.415440850 -0.585482460      1     1
8   -1.524924282  0.544323536      1     1
9   -0.106578314 -0.196693360      1     1
10  -0.035543818 -2.741920747      1     1
11   0.229491601  0.170131727      1     1
12  -1.909614050 -1.159812029      1     1
13   1.190966855 -0.356247480      1     2
14  -2.028748115  0.489991721      1     2
15  -1.079830560  1.315918615      1     2
16   0.099924682 -0.330729467      1     2
17  -0.075449795 -2.424778270      1     2
....

```

However, the estimated model is different. If one looks at the `Effect size indices` table, one finds that the clusters are now `school` and `school:class`, which is exactly how the model specifies the effects.


`r pic("examples/mixed/example1/e3.output.1.png")`

:::{ .adm .adm-note}
Note

In mixed models estimated following R package lme4 grammar, the syntax `(1 | school/class)` is just a shorthand for specifying nested random effects. The operator `school/class` expands internally into two terms: one random intercept for the grouping factor `school` and one random intercept for the interaction (i.e., nesting) `school:class`. Formally, the model random component is `(1 | school) + (1 | school:class)`.

Accordingly, `Effect size indices` table indicates that the cluster variables are `school` and `school:class`.

The __general rule__ is that in mixed models nesting does not exist, it is only a shortcut to identify the granular composition of groups of observations.

:::

# Additional material

`r include_examples("mixed")`

`r backto("mixed")`

`r issues()`